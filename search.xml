<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue组件间通信]]></title>
    <url>%2F2018%2F06%2F07%2Fvue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Vue组件通信 父子组件通信 父 -&gt; 子 子 -&gt; 父 非父子组件通信 通过变量提升（略麻烦） bus总线机制 Vuex（以后介绍） 父子组件通信父 -&gt; 子 父组件通过属性的方式传递数据给子组件，子组件通过props属性接收 vue中的数据传递为单向数据流，子组件不可以直接更改父组件传递过来的值12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id="root"&gt; &lt;counter :count = "1"&gt;&lt;/counter&gt; &lt;counter :count = "2"&gt;&lt;/counter&gt; &lt;/div&gt; &lt;script&gt; var counter = &#123; template: '&lt;div @click="handleClick"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', props: ['count'], data()&#123; return &#123; number: this.count &#125; &#125;, methods: &#123; handleClick: function()&#123; this.number++ &#125; &#125; &#125; var vm = new Vue(&#123; el: '#root', components: &#123; counter &#125;, data: &#123; total: &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 点击数字，数字可以正确的被增加 子 -&gt; 父 子组件通过派发事件的方式向父组件传值 在子组件被点击时，通过this.$emit()派发事件 在上文代码中，我们想在父组件中展示一个名为total的变量1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;div id="root"&gt; &lt;counter @inc="handleIncrease" :count = "1"&gt;&lt;/counter&gt; &lt;counter @inc="handleIncrease" :count = "2"&gt;&lt;/counter&gt; &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var counter = &#123; template: '&lt;div @click="handleClick"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', props: ['count'], data()&#123; return &#123; number: this.count &#125; &#125;, methods: &#123; handleClick: function()&#123; this.number++ this.$emit('inc', 1) &#125; &#125; &#125; var vm = new Vue(&#123; el: '#root', components: &#123; counter &#125;, data: &#123; total: 3 &#125;, methods: &#123; handleIncrease: function(s)&#123; this.total++ &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 点击数字的同时，可以看到total变量也随之改变 非父子组件通信使用bus总线机制解决非父子组件传值 本质上就是发布订阅模式 在Vue原型上定义bus为Vue实例 第一个组件改变状态时通过bus派发事件a 第二个组件在mounted周期时通过bus.$on监听事件a 123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;div id="root"&gt; &lt;child content="Tom"&gt;&lt;/child&gt; &lt;child content="Sam"&gt;&lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.prototype.bus = new Vue() Vue.component('child', &#123; data()&#123; return&#123; selfContent: this.content &#125; &#125;, props: &#123; content: String &#125;, template: "&lt;div @click='handleClick'&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;", methods: &#123; handleClick: function()&#123; this.bus.$emit('change', this.selfContent) &#125; &#125;, mounted: function()&#123; this.bus.$on('change', msg =&gt; &#123; this.selfContent = msg &#125;) &#125; &#125;) var vm = new Vue(&#123; el: '#root' &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直播原理]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%9B%B4%E6%92%AD%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[直播协议 HLS协议 RTMP协议 HTTP-FLV协议 浏览器对视频格式的支持 HLS协议 直播协议 video解析M3U8文件，得到.ts片段，每个片段就是直播流的分段。在达到播放时长之前，video会重新请求M3U8文件，得到新的.ts片段。 ps:M3U8文件里也可以是嵌套的一层M3U8文件。 M3U8文件 动态列表：用于直播，通过不断请求不同的M3U8文件进行实时播放 静态列表：一般不用（TYPE-EVENT） 全量列表：点播，M3U8文件拿到后就不会发生改变（PLAYLIST-TYPE:VOD,#EXT-X-ENDLIST） TS文件 PAT包：指向PMT包 PMT包：告知TS包中的哪些是视频，哪些是音频 PES：由很多TS包组成，连续的TS包组成一个帧 TS：TS中的header字段包含了TS包的信息（视频or音频等等） RTMP协议 基于TCP协议 实时性较差 HTTP-FLV协议 基于HTTP 在一定程度上可以避免防火墙干扰 兼容HTTP 302 使用HTTPS加密通道 很好的支持移动端]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议原理]]></title>
    <url>%2F2018%2F06%2F03%2FHTTP%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTTP协议原理 简单应用 输入URL打开网页 AJAX获取数据 img标签加载图片 网络协议分层 物理层：定义物理设备如何传输数据（网线、光缆等） 数据链路层：通讯实体之间建立数据链路的链接（传输010101之类…） 网络层：为数据在节点之间传输建立逻辑链路 传输层：向用户提供可靠的端到端的服务，向高层屏蔽了下层数据传输的细节 应用层：为应用软件提供服务，构建于TCP协议之上，屏蔽网络传输相关细节 HTTP发展历史 HTTP/0.9：只有GET命令，无HEADER等描述信息，服务器发送完毕就关闭TCP连接 HTTP/1.0：增加很多命令，增加status code和header，多字符集发送、多部分发送、权限、缓存等 HTTP/1.1：持久连接，pipeline，增加host和其他命令 HTTP/2：所有数据以二进制传输，同一个连接发送的请求不再需要按顺序来，头信息压缩以及推送等提高效率的功能（服务端主动发送信息给客户端） 三次握手1作用：防止服务端开启无用连接 时序图 URI、URL、URN URI：统一资源标志符，用来表示互联网上唯一的资源包括URL和URN URL：统一资源定位器，例：http://user:pass@host.com:80/path?query=string#hash URN：永久统一资源定位符，在资源移动之后还能找到，目前还没有成熟的使用方案 HTTP报文 起始行： 请求方法 请求地址 协议版本 / 协议版本 状态码 状态码代表的含义 首部 空行：区分首部与主体 主体HTTP方法 用来定义对于资源的操作 常见的有GET、POSTHTTP CODE 定义服务器对请求的处理结果 各个区间的code有各自的语义 好的HTTP服务可以通过CODE判断响应结果 使用node创建一个简单服务12345678const http = require(&apos;http&apos;)http.createServer(function(request, response)&#123; console.log(&apos;request come&apos;, request.url) response.end(&apos;123&apos;)&#125;).listen(8888)console.log(&apos;server listening on 8888&apos;) CORS跨域请求以及预请求 CORS跨域：在服务端设置 ‘Access-Control-Allow-Origin’: ‘*(或域名)’ CORS预请求：在服务端设置 ‘Access-Control-Allow-[Header/Methods]’:’[X-Test-***/PUT]’CORS预请求 允许方法：GET、HEAD、POST 允许Content-Type：text/plain、multipart/form-data、application/x-www-form-urlencode 其他限制：请求头限制(Accept、Accept-Language、Content-Type、Content-Language）123在预请求中，客户端会首先发送一个OPTIONS方法的请求，来获得服务端的一个认可。设置&apos;Access-Control-Max-Age&apos;:&apos;1000&apos;表示在1000时间内，不必要发送预请求 Cache-Control 可缓存性 public：http经过的任何地方都可以缓存 private：只有发起请求的浏览器可以缓存 no-cache：本地可以存缓存，但缓存要等服务器验证后才能使用到期 max-age=(seconds)：浏览器端生效 s-maxage=(seconds)：只在代理服务器生效 max-stale=(seconds)：在设置的时间内可以使用过期的缓存重新验证 must-revalidate：如果max-age过期，必须去原服务端重新发送请求 proxy-revalidate：用在缓存服务器其他 no-store：不可存储缓存 no-transform：告知代理服务器不要改变缓存内容资源验证验证头 Last-Modified：上次修改时间，配合If-Modified-Since使用 Etag：数据签名（数据修改-&gt;导致唯一签名变化）配合If-Match使用 Cookie和SessionCookie 服务端通过Set-Cookie设置 下次请求会自动带上 键值对，可设置多个 属性 max-age和expire设置过期时间 Secure只在https时发送 HttpOnly无法通过document.cookie访问 domain=.test.com表示test.com下的所有二级域名都可以访问到这个cookie 长连接 Connection: keep-alive/close 数据协商客户端发送请求时，会声明数据格式和数据限制，服务端会根据这个请求进行判断 Accept：声明数据类型 Accept-Encoding：声明数据编码方式，主要用于限制服务端的压缩方法 Accept-Language：判断语言 User-Agent：判断返回的页面时PC端还是移动端Content Content-Type：服务端返回的数据格式 Content-Encoding：服务端的数据压缩方式 Content-Language：声明语言 Redirect状态码：302 ‘Location’: ‘/newUrl’ 301：永久重定向（在浏览器端就对url进行修改，浏览器会对路由进行缓存，慎重去做） 302：临时重定向（每次请求都要经过服务端的跳转） Content-Security-Policy在服务端设置header 作用 限制资源获取 报告资源获取越权 限制方式 default-src限制全局 制定资源类型 资源类型 connect-src img-src font-src … 例子 ‘Content-Security-Policy’: ‘default-src http: https:’ ‘Content-Security-Policy’: ‘default-src \’self\’’ ‘Content-Security-Policy’: ‘form-action \’self\’’ 可以设置向服务器汇报限制规则内的请求 ‘Content-Security-Policy’: ‘default-src \’self\’;report-uri /report’ 也可以在meta标签设置 HTTPS加密 公钥私钥加密]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现继承]]></title>
    <url>%2F2018%2F05%2F02%2Fjs%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[前言 一些操作符的区别 in : 判断属性是否在实例以及实例所在的原型链上 object.hasOwnProperty() 只在属性存在于实例上时返回trun instanceof 判断一个属性是否是某个对象的实例 完美继承 12345678910111213function Parent() &#123; this.name = 'parent'; this.play = [1,2,3];&#125;//Child 继承 Parentfunction Child() &#123; Parent.call(this); this.type = 'child';&#125;Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child;let s = new Child();]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型链</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现元素垂直居中]]></title>
    <url>%2F2018%2F04%2F03%2Fcss%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[一.已知子元素宽高123456789101112131415161718192021222324&lt;h1&gt;已知宽高的情况下&lt;/h1&gt;&lt;section class="first"&gt; &lt;style&gt; .parent&#123; width:400px; height:400px; background: red; position: relative; &#125; .child&#123; position: absolute; width: 100px; height: 100px; background: yellow; top: 150px; left: 150px; &#125; &lt;/style&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 二.子元素宽高未知 12345678910111213141516171819202122232425&lt;h1&gt;子元素宽高未知1&lt;/h1&gt; &lt;section class="first"&gt; &lt;style&gt; .parent&#123; width:400px; height:400px; background: red; position: relative; &#125; .child&#123; position: absolute; background: yellow; width: 100px; height: 150px; top: 200px; left: 200px; transform: translate(-50%,-50%); &#125; &lt;/style&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 123456789101112131415161718192021222324252627&lt;h1&gt;子元素宽高未知2&lt;/h1&gt; &lt;section class="first"&gt; &lt;style&gt; .parent&#123; width:400px; height:400px; background: red; position: relative; &#125; .child&#123; position: absolute; background: yellow; width: 100px; height: 150px; top: 0; left: 0; right: 0; bottom: 0; margin: auto; &#125; &lt;/style&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 三.使用table-ceil 123456789101112131415161718192021222324&lt;h1&gt;table-ceil&lt;/h1&gt; &lt;section class="first"&gt; &lt;style&gt; .parent&#123; width:400px; height:400px; border: 1px solid red; display: table-cell; vertical-align: middle; text-align: center; &#125; .child&#123; display: inline-block; width:50px; height:50px; background: blue; &#125; &lt;/style&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 四.使用flexbox 1234567891011121314151617181920212223&lt;h1&gt;flexbox&lt;/h1&gt; &lt;section class="first"&gt; &lt;style&gt; .parent&#123; width:400px; height:400px; background: yellow; display: flex; justify-content: center; align-items: center; &#125; .child&#123; width: 50px; height: 60px; background: blue; &#125; &lt;/style&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局，垂直居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树层序遍历]]></title>
    <url>%2F2018%2F03%2F28%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[例题 (LeetCode)107. Binary Tree Level Order Traversal II 方法 定义TreeNode存储每个节点和它对应的层级。队列q用于辅助。 代码 123456789101112131415161718192021222324252627282930313233class TreeNode&#123; constructor(node, level)&#123; this.node = node; this.level = level; &#125;&#125;var levelOrderBottom = function(root) &#123; let res = []; let q = []; if(root === null)&#123; return res; &#125; q.push(new TreeNode(root, 0)); while(q.length &gt; 0)&#123; let tNode = q.shift(); let node = tNode.node; let level = tNode.level; if(level === res.length)&#123; res.push([]); &#125; res[level].push(node.val); if(node.left)&#123; q.push(new TreeNode(node.left,level+1)); &#125; if(node.right)&#123; q.push(new TreeNode(node.right,level+1)); &#125; &#125; return res.reverse()&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中this是什么]]></title>
    <url>%2F2018%2F03%2F27%2FJS-this%2F</url>
    <content type="text"><![CDATA[this的绑定规则默认绑定12345function foo() &#123; console.log( this.a);&#125;var a = 2;foo() // 2 直接使用不带任何修饰的函数引用进行调，this默认指向全局对象。严格模式不能将全局对象用于默认绑定。 隐式绑定12345678function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); //2 this指向obj对象属性引用链中只有上一层在调用位置中起作用。 隐式丢失12345678910function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo;var a = "oops, global";bar(); // oops, global 123456789101112function foo() &#123; console.log(this.a);&#125;function doFoo(fn) &#123; fn();&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "global";doFoo(obj.foo) //global 123456789function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "global";setTimeout(obj.foo, 100); // global JavaScript中内置的setTimeout()函数实现和下面的伪代码类似：123function setTimeout(fn, delay) &#123; fn();&#125; 当函数传入回调或者是语言内置函数时，会丢失this绑定，此时this为默认绑定方式。 显示绑定 使用call(..)和apply(..)方法。它们的第一个参数是一个对象，在调用函数时将其绑定到this。1234567function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;foo.call(obj); //2 但显示绑定无法解决绑定丢失的问题。 硬绑定1234567891011function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; foo.call(obj);&#125;;bar(); //2setTimeout(bar, 100); //2 硬绑定的bar不可能在修改它的this。 ES5中提供了内置方法Function.prototype.bind bind(..)会返回一个硬编码的新函数，会把指定的参数设置为this的上下文并调用原始函数。 forEach等API调用的”上下文”作用和bind一样，其实实际上就是通过call(..)或者apply(..)实现了显示绑定。 new绑定12345function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a) //2 使用new来调用函数时，会构造一个新对象并把它绑定到foo(..)调用的this上。 优先级 new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 例外情况 如果将null和undefined作为this的绑定对象传入call、apply或者bind，这些值会被忽略，实际应用的是默认绑定。 箭头函数12345678910111213function foo() &#123; return (a) =&gt; &#123; console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;;var bar = foo.call(obj1);bar.call(obj2); //2 箭头函数的this继承自它的父级，它的绑定无法更改。(new也不行) 总结1.由new调用，绑定到新创建的对象。 2.由call、apply或者bind调用，绑定到指定的对象。 3.由上下文对象调用，绑定到那个上下文对象。 4.默认，在严格模式下绑定到undefined，否则绑定到全局对象。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现三栏布局]]></title>
    <url>%2F2018%2F03%2F26%2Fcss%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1.浮动解决方法 使用float兼容性好，但需要记得清除浮动，处理好周边元素关系。 12345678910111213141516171819202122232425262728&lt;section class="layout float"&gt; &lt;style type="text/css" media="screen"&gt; .layout.float .left&#123; float: left; width: 300px; background: red; &#125; .layout.float .right&#123; float: right; width: 300px; background: blue; &#125; .layout.float .center&#123; background: yellow; overflow: auto; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;浮动解决方法&lt;/h1&gt; 1.三栏布局中间部分 2.三栏布局中间部分 3.三栏布局中间部分 &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 2.绝对定位解决方法 绝对定位快捷、简便，但是布局脱离文档流，其子元素也要脱离文档流。 1234567891011121314151617181920212223242526272829303132&lt;section class="layout absolute"&gt; &lt;style type="text/css" media="screen"&gt; .layout.absolute .left-right-center&gt;div&#123; position: absolute; &#125; .layout.absolute .left&#123; left: 0; width: 300px; background: red; &#125; .layout.absolute .center&#123; left:300px; right: 300px; background: yellow; &#125; .layout.absolute .right&#123; right: 0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;绝对定位解决方法&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 3.flexbox解决方法 flex布局教程 弹性布局，比较完美。 1234567891011121314151617181920212223242526272829303132&lt;section class="layout flexbox"&gt; &lt;style type="text/css" media="screen"&gt; .layout.flexbox&#123; margin-top: 150px; &#125; .layout.flexbox .left-right-center&#123; display: flex; &#125; .layout.flexbox .left&#123; width: 300px; background: red; &#125; .layout.flexbox .right&#123; width: 300px; background: blue; &#125; .layout.flexbox .center&#123; flex: 1; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;flexbox解决方法&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 4.table解决方法 目前使用不多,但也是一种方法。 123456789101112131415161718192021222324252627282930313233&lt;section class="layout table"&gt; &lt;style type="text/css" media="screen"&gt; .layout.table .left-right-center&#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-right-center&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width: 300px; background: red; &#125; .layout.table .right&#123; width: 300px; background: blue; &#125; .layout.table .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;table布局解决方法&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 5.grid解决方法 一种功能强大的新型布局，可以做很多复杂的事情，并且代码量很小。 1234567891011121314151617181920212223242526272829&lt;section class="layout grid"&gt; &lt;style type="text/css" media="screen"&gt; .layout.grid .left-right-center&#123; display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left&#123; background: red; &#125; .layout.grid .right&#123; background: blue; &#125; .layout.grid .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;grid布局解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Layout&lt;/title&gt; &lt;style type="text/css" media="screen"&gt; html *&#123; padding: 0; margin: 0; &#125; .layout&#123; margin-top: 20px; &#125; .layout article div&#123; min-height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class="layout float"&gt; &lt;style type="text/css" media="screen"&gt; .layout.float .left&#123; float: left; width: 300px; background: red; &#125; .layout.float .right&#123; float: right; width: 300px; background: blue; &#125; .layout.float .center&#123; background: yellow; overflow: auto; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;浮动解决方案&lt;/h1&gt; 1.三栏布局中间部分 2.三栏布局中间部分 &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout absolute"&gt; &lt;style type="text/css" media="screen"&gt; .layout.absolute .left-right-center&gt;div&#123; position: absolute; &#125; .layout.absolute .left&#123; left: 0; width: 300px; background: red; &#125; .layout.absolute .center&#123; left:300px; right: 300px; background: yellow; &#125; .layout.absolute .right&#123; right: 0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;绝对定位解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout flexbox"&gt; &lt;style type="text/css" media="screen"&gt; .layout.flexbox&#123; margin-top: 150px; &#125; .layout.flexbox .left-right-center&#123; display: flex; &#125; .layout.flexbox .left&#123; width: 300px; background: red; &#125; .layout.flexbox .right&#123; width: 300px; background: blue; &#125; .layout.flexbox .center&#123; flex: 1; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;flexbox解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout table"&gt; &lt;style type="text/css" media="screen"&gt; .layout.table .left-right-center&#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-right-center&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width: 300px; background: red; &#125; .layout.table .right&#123; width: 300px; background: blue; &#125; .layout.table .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;table布局解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout grid"&gt; &lt;style type="text/css" media="screen"&gt; .layout.grid .left-right-center&#123; display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left&#123; background: red; &#125; .layout.grid .right&#123; background: blue; &#125; .layout.grid .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;grid布局解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局，三栏布局</tag>
      </tags>
  </entry>
</search>
