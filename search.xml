<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树层序遍历]]></title>
    <url>%2F2018%2F03%2F28%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[例题 (LeetCode)107. Binary Tree Level Order Traversal II 方法 定义TreeNode存储每个节点和它对应的层级。队列q用于辅助。 代码 123456789101112131415161718192021222324252627282930313233class TreeNode&#123; constructor(node, level)&#123; this.node = node; this.level = level; &#125;&#125;var levelOrderBottom = function(root) &#123; let res = []; let q = []; if(root === null)&#123; return res; &#125; q.push(new TreeNode(root, 0)); while(q.length &gt; 0)&#123; let tNode = q.shift(); let node = tNode.node; let level = tNode.level; if(level === res.length)&#123; res.push([]); &#125; res[level].push(node.val); if(node.left)&#123; q.push(new TreeNode(node.left,level+1)); &#125; if(node.right)&#123; q.push(new TreeNode(node.right,level+1)); &#125; &#125; return res.reverse()&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中this是什么]]></title>
    <url>%2F2018%2F03%2F27%2FJS-this%2F</url>
    <content type="text"><![CDATA[this的绑定规则默认绑定12345function foo() &#123; console.log( this.a);&#125;var a = 2;foo() // 2 直接使用不带任何修饰的函数引用进行调，this默认指向全局对象。严格模式不能将全局对象用于默认绑定。 隐式绑定12345678function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); //2 this指向obj对象属性引用链中只有上一层在调用位置中起作用。 隐式丢失12345678910function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo;var a = "oops, global";bar(); // oops, global 123456789101112function foo() &#123; console.log(this.a);&#125;function doFoo(fn) &#123; fn();&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "global";doFoo(obj.foo) //global 123456789function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "global";setTimeout(obj.foo, 100); // global JavaScript中内置的setTimeout()函数实现和下面的伪代码类似：123function setTimeout(fn, delay) &#123; fn();&#125; 当函数传入回调或者是语言内置函数时，会丢失this绑定，此时this为默认绑定方式。 显示绑定 使用call(..)和apply(..)方法。它们的第一个参数是一个对象，在调用函数时将其绑定到this。1234567function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;foo.call(obj); //2 但显示绑定无法解决绑定丢失的问题。 硬绑定1234567891011function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; foo.call(obj);&#125;;bar(); //2setTimeout(bar, 100); //2 硬绑定的bar不可能在修改它的this。 ES5中提供了内置方法Function.prototype.bind bind(..)会返回一个硬编码的新函数，会把指定的参数设置为this的上下文并调用原始函数。 forEach等API调用的”上下文”作用和bind一样，其实实际上就是通过call(..)或者apply(..)实现了显示绑定。 new绑定12345function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a) //2 使用new来调用函数时，会构造一个新对象并把它绑定到foo(..)调用的this上。 优先级 new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 例外情况 如果将null和undefined作为this的绑定对象传入call、apply或者bind，这些值会被忽略，实际应用的是默认绑定。 箭头函数12345678910111213function foo() &#123; return (a) =&gt; &#123; console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;;var bar = foo.call(obj1);bar.call(obj2); //2 箭头函数的this继承自它的父级，它的绑定无法更改。(new也不行) 总结1.由new调用，绑定到新创建的对象。 2.由call、apply或者bind调用，绑定到指定的对象。 3.由上下文对象调用，绑定到那个上下文对象。 4.默认，在严格模式下绑定到undefined，否则绑定到全局对象。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JS闭包的理解]]></title>
    <url>%2F2018%2F03%2F27%2FJS%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[词法作用域12345678function init()&#123; var a = "seal"; function show()&#123; alert(a); &#125; show();&#125;init(); // seal init()创建了一个局部变量a和一个show函数。show()是定义在init()内部的函数，仅在该函数体内可用。show()内没有自己的局部变量，然而它可以访问到外部函数的变量，所以show()可以使用父函数init()中声明的变量a。但是，如果有同名变量a在show()中被定义，则会使用的show()中定义的a` 。 词法作用域中使用的域，是变量在代码中声明的位置所决定的。嵌套的函数可以访问在其外部声明的变量。 闭包 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。 引用维基百科：闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 123456var a = function () &#123; var test = &#123;&#125;; setTimeout(function () &#123; console.log(test); &#125;, 1000);&#125; 上面的例子中，test在a中定义，但在setTimeout的参数（函数）中对它保持了引用。当a被执行了，尽管a已经执行完（已经执行完），理论上来说a这个函数执行过程中产生的变量、对象都可以被销毁。但test由于被引用，所以不能随这个函数执行结束而被销毁，直到定时器里的函数被执行掉。 12345678910111213function counter()&#123; var n = 0; return &#123; count: function()&#123;return n++;&#125;, reset: function() &#123;n = 0;&#125; &#125;;&#125;var c = counter(),d = counter();c.count() //0d.count() //0c.reset() c.count() //0d.count() //1 同一作用域下的闭包之间可以共享变量，不同作用域之间互不干扰。 123456789function constfuncs()&#123; var funcs = []; for(var i = 0;i &lt; 10; i++)&#123; funcs[i] = function()&#123;return i;&#125;; &#125; return funcs;&#125;var funcs = constfuncs();funcs[5]() 上述代码创建了10个闭包，并将其放在数组中，因此它们可以共享变量i。]]></content>
      <categories>
        <category>js</category>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>闭包</tag>
        <tag>私有变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现三栏布局]]></title>
    <url>%2F2018%2F03%2F26%2Fcss%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1.浮动解决方法 使用float兼容性好，但需要记得清除浮动，处理好周边元素关系。 12345678910111213141516171819202122232425262728&lt;section class="layout float"&gt; &lt;style type="text/css" media="screen"&gt; .layout.float .left&#123; float: left; width: 300px; background: red; &#125; .layout.float .right&#123; float: right; width: 300px; background: blue; &#125; .layout.float .center&#123; background: yellow; overflow: auto; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;浮动解决方法&lt;/h1&gt; 1.三栏布局中间部分 2.三栏布局中间部分 3.三栏布局中间部分 &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 2.绝对定位解决方法 绝对定位快捷、简便，但是布局脱离文档流，其子元素也要脱离文档流。 1234567891011121314151617181920212223242526272829303132&lt;section class="layout absolute"&gt; &lt;style type="text/css" media="screen"&gt; .layout.absolute .left-right-center&gt;div&#123; position: absolute; &#125; .layout.absolute .left&#123; left: 0; width: 300px; background: red; &#125; .layout.absolute .center&#123; left:300px; right: 300px; background: yellow; &#125; .layout.absolute .right&#123; right: 0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;绝对定位解决方法&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 3.flexbox解决方法 flex布局教程 弹性布局，比较完美。 1234567891011121314151617181920212223242526272829303132&lt;section class="layout flexbox"&gt; &lt;style type="text/css" media="screen"&gt; .layout.flexbox&#123; margin-top: 150px; &#125; .layout.flexbox .left-right-center&#123; display: flex; &#125; .layout.flexbox .left&#123; width: 300px; background: red; &#125; .layout.flexbox .right&#123; width: 300px; background: blue; &#125; .layout.flexbox .center&#123; flex: 1; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;flexbox解决方法&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 4.table解决方法 目前使用不多,但也是一种方法。 123456789101112131415161718192021222324252627282930313233&lt;section class="layout table"&gt; &lt;style type="text/css" media="screen"&gt; .layout.table .left-right-center&#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-right-center&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width: 300px; background: red; &#125; .layout.table .right&#123; width: 300px; background: blue; &#125; .layout.table .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;table布局解决方法&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 5.grid解决方法 一种功能强大的新型布局，可以做很多复杂的事情，并且代码量很小。 1234567891011121314151617181920212223242526272829&lt;section class="layout grid"&gt; &lt;style type="text/css" media="screen"&gt; .layout.grid .left-right-center&#123; display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left&#123; background: red; &#125; .layout.grid .right&#123; background: blue; &#125; .layout.grid .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;grid布局解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Layout&lt;/title&gt; &lt;style type="text/css" media="screen"&gt; html *&#123; padding: 0; margin: 0; &#125; .layout&#123; margin-top: 20px; &#125; .layout article div&#123; min-height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class="layout float"&gt; &lt;style type="text/css" media="screen"&gt; .layout.float .left&#123; float: left; width: 300px; background: red; &#125; .layout.float .right&#123; float: right; width: 300px; background: blue; &#125; .layout.float .center&#123; background: yellow; overflow: auto; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;浮动解决方案&lt;/h1&gt; 1.三栏布局中间部分 2.三栏布局中间部分 &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout absolute"&gt; &lt;style type="text/css" media="screen"&gt; .layout.absolute .left-right-center&gt;div&#123; position: absolute; &#125; .layout.absolute .left&#123; left: 0; width: 300px; background: red; &#125; .layout.absolute .center&#123; left:300px; right: 300px; background: yellow; &#125; .layout.absolute .right&#123; right: 0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;绝对定位解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout flexbox"&gt; &lt;style type="text/css" media="screen"&gt; .layout.flexbox&#123; margin-top: 150px; &#125; .layout.flexbox .left-right-center&#123; display: flex; &#125; .layout.flexbox .left&#123; width: 300px; background: red; &#125; .layout.flexbox .right&#123; width: 300px; background: blue; &#125; .layout.flexbox .center&#123; flex: 1; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;flexbox解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout table"&gt; &lt;style type="text/css" media="screen"&gt; .layout.table .left-right-center&#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-right-center&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width: 300px; background: red; &#125; .layout.table .right&#123; width: 300px; background: blue; &#125; .layout.table .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;table布局解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout grid"&gt; &lt;style type="text/css" media="screen"&gt; .layout.grid .left-right-center&#123; display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left&#123; background: red; &#125; .layout.grid .right&#123; background: blue; &#125; .layout.grid .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;grid布局解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局，三栏布局</tag>
      </tags>
  </entry>
</search>
