<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS异步处理]]></title>
    <url>%2F2018%2F06%2F12%2FPromise%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[JS异步处理 Promise Async/Await 异步，即将一部分事情交给别人（浏览器或nodejs环境）处理。 Promise 将callback函数扁平化 含义Promise是一个容器，里面包含着某个未来才会结束的事件。1234567let p = new Promise((resolve,reject) =&gt; &#123; //... resolve('success')&#125;)p.then(res =&gt; &#123; console.log(res)&#125;) 从语法上说，Promise是一个对象，从它可以获取异步操作的信息。 特点：pending -&gt; fulfilled/rejected 对象的状态不受外界影响 状态一旦改变，就不会再更改 12345678910111213let p = new Promise((resolve, reject) =&gt; &#123; resolve('success'); console.log('after resolve'); reject('error');&#125;);p.then(result =&gt; &#123; console.log(result);&#125;);p.catch(result =&gt; &#123; console.log(result);&#125;); reject()的信息并不会被接收到。 Promise.prototype.then为Promise实例添加状态改变时的回调函数，参数可以有两个。 then(func1, func2) then(func1) then(null, func2) 12345678910111213141516171819202122let p = new Promise((resolve, reject) =&gt; &#123; let random = Math.random(); if (random &gt; 0.4) &#123; resolve('random &gt; 0.4'); &#125; else &#123; reject('random &lt;= 0.4'); &#125;&#125;);p.then(result =&gt; &#123; console.log('resovle', result);&#125;, result =&gt; &#123; console.log('reject', result);&#125;);// then(null, func2)let p2 = new Promise((resolve, reject) =&gt; &#123; reject('error');&#125;);let resultP = p2.then(null, result =&gt; &#123; console.log(result); return 123;&#125;); Promise.prototype.catchPromise状态变为reject时的回调函数，相当于then(null, func2)的简写 123456789let p = new Promise((resolve, reject) =&gt; &#123; reject('error');&#125;);let resultP = p.catch(result =&gt; &#123; console.log(result); return 123;&#125;);console.log(resultP); Promise.resolve将现有对象转换为Promise对象的快捷方式 12345let p1 = Promise.resolve(&#123;name: 'xixi', age: 'XXXX'&#125;);p1.then(result =&gt; &#123; console.log(result);&#125;); 当Promise.resolve()接受一个Promise对象时，直接将该对象返回 12345678910111213let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success'); &#125;, 500);&#125;);let pp = Promise.resolve(p);pp.then(result =&gt; &#123; console.log(result);&#125;);console.log(pp == p); Promise.reject快速获取一个拒绝状态的Promise对象 12345678let p = Promise.reject(123);// console.log(p);p.then(result =&gt; &#123; console.log('then', result);&#125;).catch(result =&gt; &#123; console.log('catch', result);&#125;); Promise.all &amp; Promise.race将多个Promise实例包装成一个Promise新的实例，且成功和失败返回的数据类型是不同的，Promise.all中，当所有Promise对象都成功时成功返回一个数组，失败时返回一个值。Promise.race中，只要有一个Promise成功，始终返回一个值。 1234567891011121314let p1 = Promise.resolve(123);let p2 = Promise.resolve('hello');let p3 = Promise.resolve('success');let p4 = Promise.reject('error');Promise.all([p1, p2, p3]).then(result =&gt; &#123; console.log(result);&#125;);Promise.all([p1, p2, p4]).then(result =&gt; &#123; console.log(result);&#125;).catch(result =&gt; &#123; console.log(result);&#125;); 用sleep模拟ajax请求 1234567891011121314151617function sleep(wait) &#123; return new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; res(wait); &#125;, wait); &#125;);&#125;let p1 = sleep(500);let p2 = sleep(500);let p3 = sleep(1000);Promise.all([p1, p2, p3]).then(result =&gt; &#123; console.log(result); //... // loading&#125;); Promise.race() 12345678910111213141516171819202122232425function sleep(wait) &#123; return new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; res(wait); &#125;, wait); &#125;);&#125;let p1 = sleep(500);let p0 = sleep(2000);Promise.race([p1, p0]).then(result =&gt; &#123; // console.log(result);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('error'); &#125;, 1000);&#125;);Promise.race([p0, p2]).then(result =&gt; &#123; console.log(result);&#125;).catch(result =&gt; &#123; console.log(result);&#125;); 错误机制当Promise被明确拒绝时，会发生拒绝；但如果是在构造函数中引发的错误，则会隐式拒绝(try-catch语句捕获不到)。 123456789101112// try &#123; let p = new Promise((resolve, reject) =&gt; &#123; throw new Error('im error'); // reject(new Error('im error')); &#125;);// &#125; catch (e) &#123;// console.log('catch', e);// &#125;p.catch(result =&gt; &#123; console.log(result);&#125;); Async-Await 以同步的方式写将异步操作 async-await寄生于promise，generator的语法糖 async用于声明一个函数是异步的，await相当于async-await的简写 基本语法async函数返回的是Promise对象 123456async function demo() &#123;&#125;let p = demo();console.log(p); 规则 async表示这是一个async函数，await只能在这个函数里用 await表示在这里等待promise的返回结果，然后继续进行 await后面接的因该是一个Promise对象 await await必须出现在async函数内部，不能单独使用 await等待的是Promise对象，但不必写.then()，直接可以得到返回值 123456async function demo() &#123; let result = await Promise.resolve(123); console.log(result);&#125;demo(); 应用场景：有三个函数，第二个函数依托于第一个函数的返回值，第三个函数依托于第二个函数的返回值 12345678910111213141516171819202122232425262728function sleep(wait) &#123; return new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; res(wait); &#125;, wait); &#125;);&#125;// sleep(100).then(result01 =&gt; &#123;// return sleep(result01 + 100);// &#125;).then(result02 =&gt; &#123;// return sleep(result02 + 100);// &#125;).then(result03 =&gt; &#123;// console.log(result03);// &#125;);async function demo() &#123; let result01 = await sleep(100); let result02 = await sleep(result01 + 100); let result03 = await sleep(result02 + 100); // console.log(result03); return result03;&#125;demo().then(result =&gt; &#123; // result03; console.log(result);&#125;) 错误处理 可以用try-catch语句处理await中的reject async函数的内部错误用.catch(res =&gt; {}处理 123456789101112131415161718let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('error'); &#125;, 1000);&#125;);async function demo(params) &#123; console.log(name); // try &#123; let result = await p; // &#125; catch (e) &#123; // console.log(e); // &#125;&#125;demo().catch(result =&gt; &#123; console.log(result);&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解vue三大要素]]></title>
    <url>%2F2018%2F06%2F10%2Fvue%E4%B8%89%E5%A4%A7%E8%A6%81%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[Vue框架三大要素 响应式 模板解析 render函数 响应式：vue如何监听到data属性的变化vue中如何实现响应式 什么是响应式 Object.defineProperty 响应式： 修改data属性之后，vue立刻监听到 data属性被代理到vm上 demo：12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;age&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; name: 'seal', age: 24 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 问题： vm.name=‘***’，修改会立刻生效的监听机制如何实现？(获取属性/赋值属性如何监听？) data中的属性是如何代理到vm上面的？ 答1： 通过Object.defineProperty实现。 1234567891011121314var obj = &#123;&#125;var name = 'zhangsan'Object.defineProperty(obj, 'name', &#123; get: function()&#123; console.log('get') return name &#125;, set: function(newVal)&#123; console.log('set') name = newVal &#125;&#125;)console.log(obj.name) //可以监听到obj.name='wangwu' 即，通过defineProperty将data里面的属性代理到vm对象上。 模板解析 模板是什么 render函数 render 与 vdom 模板： 本质是字符串 有逻辑，如v-if v-for等 与html风格很像，但有很大区别 最终要转换为html显示 模板最终必须转换成JS代码（必须用JS处理逻辑、并转换为html） 模板最终要转换成一个JS函数，这个函数就是render函数 render函数 模板中所有信息都包含在了render函数中 this即vm price 即 this.price，即vm.price，data中的price _c即this._c，即vm._c 123456var vm = new Vue(&#123; el: '#app', data: &#123; age: 24 &#125; &#125;) 简单的render函数：123456789101112131415function render()&#123; with(this)&#123; // this就是vm return _c( 'div', &#123; attrs: &#123;'id': 'app'&#125; &#125;, [ _c( 'p',[_v(_s(age))] ) ] ) &#125; &#125; 一个todo-list-demo： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;to-do-list by vue&lt;/title&gt; &lt;script src="./vue-2.5.13.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div&gt; &lt;input v-model="title"&gt; &lt;button v-on:click="add"&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for="item in list"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; // data 独立 var data = &#123; title: '', list: [] &#125; // 初始化 Vue 实例 var vm = new Vue(&#123; el: '#app', data: data, methods: &#123; add: function () &#123; this.list.push(this.title) this.title = '' &#125; &#125; &#125;) 在vue.js源码中找到：1var code = generate(ast, options); 并添加：1alert(code.render) 保存并刷新，就可以看到弹出的render函数了，将其格式化后为： this就是vm _c(标签名，属性)用来创建一个标签 []表示子元素 directives表示v-model的一些信息 _v(“ ”)创建文本节点 _l(list, function(item){})创建子元素（返回一个数组） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556with(this)&#123; // this 就是 vm return _c( //创建一个标签 'div', &#123; attrs:&#123;"id":"app"&#125; &#125;, [ //创建子元素 _c( 'div', [ _c( //创建input 'input', &#123; directives:[ &#123; name:"model", rawName:"v-model", value:(title), expression:"title" &#125; ], domProps:&#123; "value":(title) &#125;, on:&#123; //如果input数据有改动，就会触发这个事件 "input":function($event)&#123; if($event.target.composing)return; title=$event.target.value &#125; &#125; &#125; ), _v(" "), _c( //创建button 'button', &#123; on:&#123; "click":add //vm.add &#125; &#125;, [_v("submit")] //文本节点 ) ] ), _v(" "), _c('div', [ _c( 'ul', _l((list),function(item)&#123;return _c('li',[_v(_s(item))])&#125;) ) ] ) ] )&#125; render函数执行之后实际上返回的是一个vnode 页面渲染时执行updateComponent： 12345678910111213function updateComponent()&#123; vm._update(vm._render())&#125;function _update(vnode)&#123; const preVnode = vm._vnode vm._vnode = vnode if(!preVnode)&#123; vm.$el = vm.__patch__(vm.$el, vnode) //页面首次渲染时执行 &#125; else &#123; vm.__patch__(preVnode, vnode) //修改data属性时执行 &#125;&#125; 小结 模板：字符串，有逻辑，嵌入JS变量 模板必须转换为JS代码 render函数执行时返回vnode updateComponent函数 Vue的整个实现流程 解析模板成render函数 响应式开始监听 首次渲染，显示页面且绑定依赖 data属性变化，触发rerender 修改属性，被响应式set监听到 set中执行updateComponent updateComponent重新执行vm._render() 生成的preVnode和vnode，通过patch对比 渲染到html中 首次渲染时，会对响应式的get方法监听： data中有很多属性，有些被用到，有些可能不被用到 被用到的会走get，不被用到的不会走get 为走到get的属性，set时我们也无需关心 避免不必要的重复渲染]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件间通信]]></title>
    <url>%2F2018%2F06%2F07%2Fvue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Vue组件通信 父子组件通信 父 -&gt; 子 子 -&gt; 父 非父子组件通信 通过变量提升（略麻烦） bus总线机制 Vuex（以后介绍） 父子组件通信父 -&gt; 子 父组件通过属性的方式传递数据给子组件，子组件通过props属性接收 vue中的数据传递为单向数据流，子组件不可以直接更改父组件传递过来的值12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id="root"&gt; &lt;counter :count = "1"&gt;&lt;/counter&gt; &lt;counter :count = "2"&gt;&lt;/counter&gt; &lt;/div&gt; &lt;script&gt; var counter = &#123; template: '&lt;div @click="handleClick"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', props: ['count'], data()&#123; return &#123; number: this.count &#125; &#125;, methods: &#123; handleClick: function()&#123; this.number++ &#125; &#125; &#125; var vm = new Vue(&#123; el: '#root', components: &#123; counter &#125;, data: &#123; total: &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 点击数字，数字可以正确的被增加 子 -&gt; 父 子组件通过派发事件的方式向父组件传值 在子组件被点击时，通过this.$emit()派发事件 在上文代码中，我们想在父组件中展示一个名为total的变量1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;div id="root"&gt; &lt;counter @inc="handleIncrease" :count = "1"&gt;&lt;/counter&gt; &lt;counter @inc="handleIncrease" :count = "2"&gt;&lt;/counter&gt; &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var counter = &#123; template: '&lt;div @click="handleClick"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', props: ['count'], data()&#123; return &#123; number: this.count &#125; &#125;, methods: &#123; handleClick: function()&#123; this.number++ this.$emit('inc', 1) &#125; &#125; &#125; var vm = new Vue(&#123; el: '#root', components: &#123; counter &#125;, data: &#123; total: 3 &#125;, methods: &#123; handleIncrease: function(s)&#123; this.total++ &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 点击数字的同时，可以看到total变量也随之改变 非父子组件通信使用bus总线机制解决非父子组件传值 本质上就是发布订阅模式 在Vue原型上定义bus为Vue实例 第一个组件改变状态时通过bus派发事件a 第二个组件在mounted周期时通过bus.$on监听事件a 123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;div id="root"&gt; &lt;child content="Tom"&gt;&lt;/child&gt; &lt;child content="Sam"&gt;&lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.prototype.bus = new Vue() Vue.component('child', &#123; data()&#123; return&#123; selfContent: this.content &#125; &#125;, props: &#123; content: String &#125;, template: "&lt;div @click='handleClick'&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;", methods: &#123; handleClick: function()&#123; this.bus.$emit('change', this.selfContent) &#125; &#125;, mounted: function()&#123; this.bus.$on('change', msg =&gt; &#123; this.selfContent = msg &#125;) &#125; &#125;) var vm = new Vue(&#123; el: '#root' &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直播原理]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%9B%B4%E6%92%AD%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[直播协议 HLS协议 RTMP协议 HTTP-FLV协议 浏览器对视频格式的支持 HLS协议 直播协议 video解析M3U8文件，得到.ts片段，每个片段就是直播流的分段。在达到播放时长之前，video会重新请求M3U8文件，得到新的.ts片段。 ps:M3U8文件里也可以是嵌套的一层M3U8文件。 M3U8文件 动态列表：用于直播，通过不断请求不同的M3U8文件进行实时播放 静态列表：一般不用（TYPE-EVENT） 全量列表：点播，M3U8文件拿到后就不会发生改变（PLAYLIST-TYPE:VOD,#EXT-X-ENDLIST） TS文件 PAT包：指向PMT包 PMT包：告知TS包中的哪些是视频，哪些是音频 PES：由很多TS包组成，连续的TS包组成一个帧 TS：TS中的header字段包含了TS包的信息（视频or音频等等） RTMP协议 基于TCP协议 实时性较差 HTTP-FLV协议 基于HTTP 在一定程度上可以避免防火墙干扰 兼容HTTP 302 使用HTTPS加密通道 很好的支持移动端]]></content>
      <categories>
        <category>直播</category>
      </categories>
      <tags>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议原理]]></title>
    <url>%2F2018%2F06%2F03%2FHTTP%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTTP协议原理 简单应用 输入URL打开网页 AJAX获取数据 img标签加载图片 网络协议分层 物理层：定义物理设备如何传输数据（网线、光缆等） 数据链路层：通讯实体之间建立数据链路的链接（传输010101之类…） 网络层：为数据在节点之间传输建立逻辑链路 传输层：向用户提供可靠的端到端的服务，向高层屏蔽了下层数据传输的细节 应用层：为应用软件提供服务，构建于TCP协议之上，屏蔽网络传输相关细节 HTTP发展历史 HTTP/0.9：只有GET命令，无HEADER等描述信息，服务器发送完毕就关闭TCP连接 HTTP/1.0：增加很多命令，增加status code和header，多字符集发送、多部分发送、权限、缓存等 HTTP/1.1：持久连接，pipeline，增加host和其他命令 HTTP/2：所有数据以二进制传输，同一个连接发送的请求不再需要按顺序来，头信息压缩以及推送等提高效率的功能（服务端主动发送信息给客户端） 三次握手1作用：防止服务端开启无用连接 时序图 URI、URL、URN URI：统一资源标志符，用来表示互联网上唯一的资源包括URL和URN URL：统一资源定位器，例：http://user:pass@host.com:80/path?query=string#hash URN：永久统一资源定位符，在资源移动之后还能找到，目前还没有成熟的使用方案 HTTP报文 起始行： 请求方法 请求地址 协议版本 / 协议版本 状态码 状态码代表的含义 首部 空行：区分首部与主体 主体HTTP方法 用来定义对于资源的操作 常见的有GET、POSTHTTP CODE 定义服务器对请求的处理结果 各个区间的code有各自的语义 好的HTTP服务可以通过CODE判断响应结果 使用node创建一个简单服务12345678const http = require(&apos;http&apos;)http.createServer(function(request, response)&#123; console.log(&apos;request come&apos;, request.url) response.end(&apos;123&apos;)&#125;).listen(8888)console.log(&apos;server listening on 8888&apos;) CORS跨域请求以及预请求 CORS跨域：在服务端设置 ‘Access-Control-Allow-Origin’: ‘*(或域名)’ CORS预请求：在服务端设置 ‘Access-Control-Allow-[Header/Methods]’:’[X-Test-***/PUT]’CORS预请求 允许方法：GET、HEAD、POST 允许Content-Type：text/plain、multipart/form-data、application/x-www-form-urlencode 其他限制：请求头限制(Accept、Accept-Language、Content-Type、Content-Language）123在预请求中，客户端会首先发送一个OPTIONS方法的请求，来获得服务端的一个认可。设置&apos;Access-Control-Max-Age&apos;:&apos;1000&apos;表示在1000时间内，不必要发送预请求 Cache-Control 可缓存性 public：http经过的任何地方都可以缓存 private：只有发起请求的浏览器可以缓存 no-cache：本地可以存缓存，但缓存要等服务器验证后才能使用到期 max-age=(seconds)：浏览器端生效 s-maxage=(seconds)：只在代理服务器生效 max-stale=(seconds)：在设置的时间内可以使用过期的缓存重新验证 must-revalidate：如果max-age过期，必须去原服务端重新发送请求 proxy-revalidate：用在缓存服务器其他 no-store：不可存储缓存 no-transform：告知代理服务器不要改变缓存内容资源验证验证头 Last-Modified：上次修改时间，配合If-Modified-Since使用 Etag：数据签名（数据修改-&gt;导致唯一签名变化）配合If-Match使用 Cookie和SessionCookie 服务端通过Set-Cookie设置 下次请求会自动带上 键值对，可设置多个 属性 max-age和expire设置过期时间 Secure只在https时发送 HttpOnly无法通过document.cookie访问 domain=.test.com表示test.com下的所有二级域名都可以访问到这个cookie 长连接 Connection: keep-alive/close 数据协商客户端发送请求时，会声明数据格式和数据限制，服务端会根据这个请求进行判断 Accept：声明数据类型 Accept-Encoding：声明数据编码方式，主要用于限制服务端的压缩方法 Accept-Language：判断语言 User-Agent：判断返回的页面时PC端还是移动端Content Content-Type：服务端返回的数据格式 Content-Encoding：服务端的数据压缩方式 Content-Language：声明语言 Redirect状态码：302 ‘Location’: ‘/newUrl’ 301：永久重定向（在浏览器端就对url进行修改，浏览器会对路由进行缓存，慎重去做） 302：临时重定向（每次请求都要经过服务端的跳转） Content-Security-Policy在服务端设置header 作用 限制资源获取 报告资源获取越权 限制方式 default-src限制全局 制定资源类型 资源类型 connect-src img-src font-src … 例子 ‘Content-Security-Policy’: ‘default-src http: https:’ ‘Content-Security-Policy’: ‘default-src \’self\’’ ‘Content-Security-Policy’: ‘form-action \’self\’’ 可以设置向服务器汇报限制规则内的请求 ‘Content-Security-Policy’: ‘default-src \’self\’;report-uri /report’ 也可以在meta标签设置 HTTPS加密 公钥私钥加密]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现继承]]></title>
    <url>%2F2018%2F05%2F02%2Fjs%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[前言 一些操作符的区别 in : 判断属性是否在实例以及实例所在的原型链上 object.hasOwnProperty() 只在属性存在于实例上时返回trun instanceof 判断一个属性是否是某个对象的实例 完美继承 12345678910111213function Parent() &#123; this.name = 'parent'; this.play = [1,2,3];&#125;//Child 继承 Parentfunction Child() &#123; Parent.call(this); this.type = 'child';&#125;Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child;let s = new Child();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型链</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现元素垂直居中]]></title>
    <url>%2F2018%2F04%2F03%2Fcss%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[一.已知子元素宽高123456789101112131415161718192021222324&lt;h1&gt;已知宽高的情况下&lt;/h1&gt;&lt;section class="first"&gt; &lt;style&gt; .parent&#123; width:400px; height:400px; background: red; position: relative; &#125; .child&#123; position: absolute; width: 100px; height: 100px; background: yellow; top: 150px; left: 150px; &#125; &lt;/style&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 二.子元素宽高未知 12345678910111213141516171819202122232425&lt;h1&gt;子元素宽高未知1&lt;/h1&gt; &lt;section class="first"&gt; &lt;style&gt; .parent&#123; width:400px; height:400px; background: red; position: relative; &#125; .child&#123; position: absolute; background: yellow; width: 100px; height: 150px; top: 200px; left: 200px; transform: translate(-50%,-50%); &#125; &lt;/style&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 123456789101112131415161718192021222324252627&lt;h1&gt;子元素宽高未知2&lt;/h1&gt; &lt;section class="first"&gt; &lt;style&gt; .parent&#123; width:400px; height:400px; background: red; position: relative; &#125; .child&#123; position: absolute; background: yellow; width: 100px; height: 150px; top: 0; left: 0; right: 0; bottom: 0; margin: auto; &#125; &lt;/style&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 三.使用table-ceil 123456789101112131415161718192021222324&lt;h1&gt;table-ceil&lt;/h1&gt; &lt;section class="first"&gt; &lt;style&gt; .parent&#123; width:400px; height:400px; border: 1px solid red; display: table-cell; vertical-align: middle; text-align: center; &#125; .child&#123; display: inline-block; width:50px; height:50px; background: blue; &#125; &lt;/style&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 四.使用flexbox 1234567891011121314151617181920212223&lt;h1&gt;flexbox&lt;/h1&gt; &lt;section class="first"&gt; &lt;style&gt; .parent&#123; width:400px; height:400px; background: yellow; display: flex; justify-content: center; align-items: center; &#125; .child&#123; width: 50px; height: 60px; background: blue; &#125; &lt;/style&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局，垂直居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树层序遍历]]></title>
    <url>%2F2018%2F03%2F28%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[例题 (LeetCode)107. Binary Tree Level Order Traversal II 方法 定义TreeNode存储每个节点和它对应的层级。队列q用于辅助。 代码 123456789101112131415161718192021222324252627282930313233class TreeNode&#123; constructor(node, level)&#123; this.node = node; this.level = level; &#125;&#125;var levelOrderBottom = function(root) &#123; let res = []; let q = []; if(root === null)&#123; return res; &#125; q.push(new TreeNode(root, 0)); while(q.length &gt; 0)&#123; let tNode = q.shift(); let node = tNode.node; let level = tNode.level; if(level === res.length)&#123; res.push([]); &#125; res[level].push(node.val); if(node.left)&#123; q.push(new TreeNode(node.left,level+1)); &#125; if(node.right)&#123; q.push(new TreeNode(node.right,level+1)); &#125; &#125; return res.reverse()&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中this是什么]]></title>
    <url>%2F2018%2F03%2F27%2FJS-this%2F</url>
    <content type="text"><![CDATA[this的绑定规则默认绑定12345function foo() &#123; console.log( this.a);&#125;var a = 2;foo() // 2 直接使用不带任何修饰的函数引用进行调，this默认指向全局对象。严格模式不能将全局对象用于默认绑定。 隐式绑定12345678function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); //2 this指向obj对象属性引用链中只有上一层在调用位置中起作用。 隐式丢失12345678910function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo;var a = "oops, global";bar(); // oops, global 123456789101112function foo() &#123; console.log(this.a);&#125;function doFoo(fn) &#123; fn();&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "global";doFoo(obj.foo) //global 123456789function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "global";setTimeout(obj.foo, 100); // global JavaScript中内置的setTimeout()函数实现和下面的伪代码类似：123function setTimeout(fn, delay) &#123; fn();&#125; 当函数传入回调或者是语言内置函数时，会丢失this绑定，此时this为默认绑定方式。 显示绑定 使用call(..)和apply(..)方法。它们的第一个参数是一个对象，在调用函数时将其绑定到this。1234567function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;foo.call(obj); //2 但显示绑定无法解决绑定丢失的问题。 硬绑定1234567891011function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; foo.call(obj);&#125;;bar(); //2setTimeout(bar, 100); //2 硬绑定的bar不可能在修改它的this。 ES5中提供了内置方法Function.prototype.bind bind(..)会返回一个硬编码的新函数，会把指定的参数设置为this的上下文并调用原始函数。 forEach等API调用的”上下文”作用和bind一样，其实实际上就是通过call(..)或者apply(..)实现了显示绑定。 new绑定12345function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a) //2 使用new来调用函数时，会构造一个新对象并把它绑定到foo(..)调用的this上。 优先级 new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 例外情况 如果将null和undefined作为this的绑定对象传入call、apply或者bind，这些值会被忽略，实际应用的是默认绑定。 箭头函数12345678910111213function foo() &#123; return (a) =&gt; &#123; console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;;var bar = foo.call(obj1);bar.call(obj2); //2 箭头函数的this继承自它的父级，它的绑定无法更改。(new也不行) 总结1.由new调用，绑定到新创建的对象。 2.由call、apply或者bind调用，绑定到指定的对象。 3.由上下文对象调用，绑定到那个上下文对象。 4.默认，在严格模式下绑定到undefined，否则绑定到全局对象。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现三栏布局]]></title>
    <url>%2F2018%2F03%2F26%2Fcss%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1.浮动解决方法 使用float兼容性好，但需要记得清除浮动，处理好周边元素关系。 12345678910111213141516171819202122232425262728&lt;section class="layout float"&gt; &lt;style type="text/css" media="screen"&gt; .layout.float .left&#123; float: left; width: 300px; background: red; &#125; .layout.float .right&#123; float: right; width: 300px; background: blue; &#125; .layout.float .center&#123; background: yellow; overflow: auto; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;浮动解决方法&lt;/h1&gt; 1.三栏布局中间部分 2.三栏布局中间部分 3.三栏布局中间部分 &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 2.绝对定位解决方法 绝对定位快捷、简便，但是布局脱离文档流，其子元素也要脱离文档流。 1234567891011121314151617181920212223242526272829303132&lt;section class="layout absolute"&gt; &lt;style type="text/css" media="screen"&gt; .layout.absolute .left-right-center&gt;div&#123; position: absolute; &#125; .layout.absolute .left&#123; left: 0; width: 300px; background: red; &#125; .layout.absolute .center&#123; left:300px; right: 300px; background: yellow; &#125; .layout.absolute .right&#123; right: 0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;绝对定位解决方法&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 3.flexbox解决方法 flex布局教程 弹性布局，比较完美。 1234567891011121314151617181920212223242526272829303132&lt;section class="layout flexbox"&gt; &lt;style type="text/css" media="screen"&gt; .layout.flexbox&#123; margin-top: 150px; &#125; .layout.flexbox .left-right-center&#123; display: flex; &#125; .layout.flexbox .left&#123; width: 300px; background: red; &#125; .layout.flexbox .right&#123; width: 300px; background: blue; &#125; .layout.flexbox .center&#123; flex: 1; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;flexbox解决方法&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 4.table解决方法 目前使用不多,但也是一种方法。 123456789101112131415161718192021222324252627282930313233&lt;section class="layout table"&gt; &lt;style type="text/css" media="screen"&gt; .layout.table .left-right-center&#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-right-center&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width: 300px; background: red; &#125; .layout.table .right&#123; width: 300px; background: blue; &#125; .layout.table .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;table布局解决方法&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 5.grid解决方法 一种功能强大的新型布局，可以做很多复杂的事情，并且代码量很小。 1234567891011121314151617181920212223242526272829&lt;section class="layout grid"&gt; &lt;style type="text/css" media="screen"&gt; .layout.grid .left-right-center&#123; display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left&#123; background: red; &#125; .layout.grid .right&#123; background: blue; &#125; .layout.grid .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;grid布局解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Layout&lt;/title&gt; &lt;style type="text/css" media="screen"&gt; html *&#123; padding: 0; margin: 0; &#125; .layout&#123; margin-top: 20px; &#125; .layout article div&#123; min-height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class="layout float"&gt; &lt;style type="text/css" media="screen"&gt; .layout.float .left&#123; float: left; width: 300px; background: red; &#125; .layout.float .right&#123; float: right; width: 300px; background: blue; &#125; .layout.float .center&#123; background: yellow; overflow: auto; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;浮动解决方案&lt;/h1&gt; 1.三栏布局中间部分 2.三栏布局中间部分 &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout absolute"&gt; &lt;style type="text/css" media="screen"&gt; .layout.absolute .left-right-center&gt;div&#123; position: absolute; &#125; .layout.absolute .left&#123; left: 0; width: 300px; background: red; &#125; .layout.absolute .center&#123; left:300px; right: 300px; background: yellow; &#125; .layout.absolute .right&#123; right: 0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;绝对定位解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout flexbox"&gt; &lt;style type="text/css" media="screen"&gt; .layout.flexbox&#123; margin-top: 150px; &#125; .layout.flexbox .left-right-center&#123; display: flex; &#125; .layout.flexbox .left&#123; width: 300px; background: red; &#125; .layout.flexbox .right&#123; width: 300px; background: blue; &#125; .layout.flexbox .center&#123; flex: 1; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;flexbox解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout table"&gt; &lt;style type="text/css" media="screen"&gt; .layout.table .left-right-center&#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-right-center&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width: 300px; background: red; &#125; .layout.table .right&#123; width: 300px; background: blue; &#125; .layout.table .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;table布局解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;section class="layout grid"&gt; &lt;style type="text/css" media="screen"&gt; .layout.grid .left-right-center&#123; display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left&#123; background: red; &#125; .layout.grid .right&#123; background: blue; &#125; .layout.grid .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;grid布局解决方案&lt;/h1&gt; 1.这是三栏布局中间部分 1.这是三栏布局中间部分 1.这是三栏布局中间部分 &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局，三栏布局</tag>
      </tags>
  </entry>
</search>
